<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Smak Chess Viewer</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- chess rules engine, used to turn UCI into board positions + SAN -->
<script src="https://cdn.jsdelivr.net/npm/chess.js@1.0.0/dist/chess.min.js"></script>

<style>
  :root {
    --bg: #0d1117;
    --fg: #e6edf3;
    --card: #161b22;
    --border: #30363d;
    --muted: #8b949e;
    --light-square: #f0d9b5;
    --dark-square: #b58863;
  }

  body {
    margin: 0;
    background: var(--bg);
    color: var(--fg);
    font-family: system-ui, sans-serif;
  }

  header {
    padding: 12px 20px;
    background: #090d12;
    display: flex;
    align-items: center;
    gap: 14px;
    border-bottom: 1px solid var(--border);
  }

  header strong {
    font-size: 15px;
  }

  header select, header button {
    background: #0d1117;
    color: var(--fg);
    border-radius: 999px;
    border: 1px solid var(--border);
    padding: 4px 10px;
    font-size: 13px;
  }

  header button {
    cursor: pointer;
  }

  header button:hover {
    background: #111827;
  }

  #status {
    margin-left: auto;
    font-size: 12px;
    color: var(--muted);
  }

  main {
    display: grid;
    grid-template-columns: 520px 1fr;
    gap: 20px;
    padding: 20px;
  }

  .panel {
    padding: 14px 16px;
    border-radius: 10px;
    background: var(--card);
    border: 1px solid var(--border);
  }

  h2 {
    margin: 0 0 8px 0;
    font-size: 16px;
  }

  #board {
    width: 100%;
    max-width: 480px;
    aspect-ratio: 1 / 1;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-auto-rows: 1fr;
    border-radius: 10px;
    overflow: hidden;
    margin: 0 auto;
  }

  .square {
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 34px;
    user-select: none;
  }

  .light { background: var(--light-square); }
  .dark  { background: var(--dark-square); }

  #gameInfo {
    margin-top: 10px;
    padding: 8px 10px;
    background: #0f141a;
    border-radius: 7px;
    border: 1px solid var(--border);
    font-family: ui-monospace, Menlo, Consolas, monospace;
    white-space: pre-line;
    font-size: 13px;
  }

  .controls {
    margin-top: 10px;
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .controls button {
    width: 32px;
    height: 32px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: #0d1117;
    color: var(--fg);
    cursor: pointer;
  }

  .controls button:hover {
    background: #111827;
  }

  #plyLabel {
    margin-left: 10px;
    font-size: 13px;
    color: var(--muted);
  }

  #movesTable {
    width: 100%;
    margin-top: 6px;
    border-collapse: collapse;
    font-size: 13px;
  }

  #movesTable th, #movesTable td {
    padding: 6px 5px;
    border-bottom: 1px solid var(--border);
  }

  #movesTable th {
    text-align: left;
    font-size: 12px;
    color: var(--muted);
  }

  #movesTable tr.active {
    background: #1d2633;
  }

  #movesTable tr:hover {
    background: #1b2230;
    cursor: pointer;
  }

  .flag {
    font-size: 12px;
    color: #f97373;
  }

  @media (max-width: 900px) {
    main {
      grid-template-columns: 1fr;
    }
  }
</style>
</head>

<body>

<header>
  <strong>♟ Smak Viewer</strong>

  Game:
  <select id="gameSelect"></select>

  <button id="refreshBtn">↻ Refresh</button>
  <span id="status"></span>
</header>

<main>

  <!-- LEFT: board + meta + buttons -->
  <div class="panel">
    <h2>Board</h2>
    <div id="board"></div>

    <div id="gameInfo"></div>

    <div class="controls">
      <button id="btnFirst">⏮</button>
      <button id="btnPrev">◀</button>
      <button id="btnNext">▶</button>
      <button id="btnLast">⏭</button>
      <span id="plyLabel"></span>
    </div>
  </div>

  <!-- RIGHT: moves -->
  <div class="panel">
    <h2>Moves</h2>
    <table id="movesTable">
      <thead>
      <tr><th>#</th><th>Side</th><th>Move</th><th>Flags</th></tr>
      </thead>
      <tbody id="movesBody"></tbody>
    </table>
  </div>

</main>

<script>
  const el = {
    gameSelect: document.getElementById('gameSelect'),
    refreshBtn: document.getElementById('refreshBtn'),
    status: document.getElementById('status'),
    board: document.getElementById('board'),
    gameInfo: document.getElementById('gameInfo'),
    movesBody: document.getElementById('movesBody'),
    btnFirst: document.getElementById('btnFirst'),
    btnPrev: document.getElementById('btnPrev'),
    btnNext: document.getElementById('btnNext'),
    btnLast: document.getElementById('btnLast'),
    plyLabel: document.getElementById('plyLabel'),
  };

  // current viewer state
  const state = {
    game: null,
    rawMoves: [],
    moves: [],   // enriched with san, check, mate
    fens: [],    // fens[0] = start, fens[i] = after move i
    index: -1,   // -1 = start position
  };

  async function fetchJson(url) {
    const r = await fetch(url);
    if (!r.ok) throw new Error(await r.text());
    return r.json();
  }

  // piece -> unicode
  function pieceChar(c) {
    switch (c) {
      case 'P': return '♙';
      case 'N': return '♘';
      case 'B': return '♗';
      case 'R': return '♖';
      case 'Q': return '♕';
      case 'K': return '♔';
      case 'p': return '♟';
      case 'n': return '♞';
      case 'b': return '♝';
      case 'r': return '♜';
      case 'q': return '♛';
      case 'k': return '♚';
      default: return '';
    }
  }

  function renderBoardFromFen(fen) {
    if (!fen) {
      el.board.innerHTML = '';
      return;
    }
    const placement = fen.split(' ')[0];
    const rows = placement.split('/');

    el.board.innerHTML = '';

    for (let r = 0; r < 8; r++) {
      let file = 0;
      for (const ch of rows[r]) {
        if (/\d/.test(ch)) {
          for (let i = 0; i < +ch; i++) {
            addSquare(r, file++, '');
          }
        } else {
          addSquare(r, file, pieceChar(ch));
          file++;
        }
      }
    }
  }

  function addSquare(rank, file, piece) {
    const sq = document.createElement('div');
    sq.classList.add('square');
    const isLight = (rank + file) % 2 === 0;
    sq.classList.add(isLight ? 'light' : 'dark');
    sq.textContent = piece;
    el.board.appendChild(sq);
  }

  function fenAt(index) {
    if (!state.fens.length) return null;
    // index -1 => fens[0]
    if (index < 0) return state.fens[0];
    const idx = Math.min(index + 1, state.fens.length - 1);
    return state.fens[idx];
  }

  function updatePlyLabel() {
    if (state.index < 0) {
      el.plyLabel.textContent = "Initial position";
      return;
    }
    const m = state.moves[state.index];
    const player = (m.plyno % 2 === 1 ? "White" : "Black");
    el.plyLabel.textContent = `Ply ${m.plyno} (${player})`;
  }

  function highlightRows() {
    [...el.movesBody.children].forEach(tr => tr.classList.remove('active'));
    if (state.index >= 0 && state.index < state.moves.length) {
      const row = el.movesBody.querySelector(`tr[data-index="${state.index}"]`);
      if (row) row.classList.add('active');
    }
  }

  function showIndex(i) {
    if (!state.game) return;
    if (i < -1) i = -1;
    if (i >= state.moves.length) i = state.moves.length - 1;

    state.index = i;
    const fen = fenAt(i);
    renderBoardFromFen(fen);
    updatePlyLabel();
    highlightRows();
  }

  function renderGameInfo() {
    const g = state.game;
    const start = g.gamestart ? new Date(g.gamestart).toLocaleString() : "-";
    const end   = g.gameend   ? new Date(g.gameend).toLocaleString()   : "-";
    const result = g.result || "UNKNOWN";
    const st = g.state || "-";

    el.gameInfo.textContent =
`Start:  ${start}
End:    ${end}
State:  ${st}
Result: ${result}`;
  }

  function renderMoves() {
    el.movesBody.innerHTML = "";
    state.moves.forEach((m, idx) => {
      const tr = document.createElement('tr');
      tr.dataset.index = idx;

      const moveNo = (m.plyno % 2 === 1 ? Math.ceil(m.plyno / 2) : "");
      const side = (m.plyno % 2 === 1 ? "W" : "B");

      const flagText = m.isMate ? "#" : (m.isCheck ? "+" : "");
      const flagsHtml = flagText ? `<span class="flag">${flagText}</span>` : "";

      tr.innerHTML = `
        <td>${moveNo}</td>
        <td>${side}</td>
        <td>${m.san || m.uci}</td>
        <td>${flagsHtml}</td>
      `;

      tr.addEventListener("click", () => showIndex(idx));
      el.movesBody.appendChild(tr);
    });
  }

  // Build SAN + FEN on frontend using chess.js and only UCI
  function buildFromUci(rawMoves) {
    if (typeof Chess === "undefined") {
      // fallback: just show uci, no board logic
      state.fens = [];
      return rawMoves.map(m => ({
        ...m,
        san: m.uci,
        isCheck: false,
        isMate: false,
      }));
    }

    const game = new Chess(); // standard starting position
    const sorted = [...rawMoves].sort((a, b) => (a.plyno ?? 0) - (b.plyno ?? 0));

    const fens = [];
    const enriched = [];

    // initial position
    fens.push(game.fen());

    for (const m of sorted) {
      const uci = m.uci || "";
      if (uci.length < 4) continue;

      const moveObj = {
        from: uci.slice(0, 2),
        to:   uci.slice(2, 4)
      };

      if (uci.length >= 5) {
        moveObj.promotion = uci[4].toLowerCase();
      } else if (m.promotion) {
        moveObj.promotion = "q";
      }

      const res = game.move(moveObj);
      let san = uci;
      if (res && res.san) san = res.san;

      const isMate = san.includes("#");
      const isCheck = !isMate && san.includes("+");

      enriched.push({
        ...m,
        san,
        isCheck,
        isMate
      });

      fens.push(game.fen());
    }

    state.fens = fens;
    return enriched;
  }

  async function loadGame(id) {
    try {
      el.status.textContent = "Loading...";
      const game = await fetchJson(`/games/${id}`);
      const rawMoves = await fetchJson(`/moves/${id}`);

      state.game = game;
      state.rawMoves = rawMoves || [];
      state.moves = buildFromUci(state.rawMoves);
      state.index = -1;

      renderGameInfo();
      renderMoves();
      showIndex(-1);

      el.status.textContent = `${state.moves.length} plies • ${game.result}`;
    } catch (e) {
      el.status.textContent = "Error: " + e.message;
    }
  }

  async function loadGameList() {
    try {
      const games = await fetchJson("/games");
      if (!games || !games.length) {
        el.gameSelect.innerHTML = "<option>(no games)</option>";
        el.status.textContent = "No games found";
        return;
      }

      el.gameSelect.innerHTML = games
        .map(g => `<option value="${g.id}">Game #${g.id} (${g.result})</option>`)
        .join("");

      await loadGame(games[0].id);
    } catch (e) {
      el.status.textContent = "Error loading games";
    }
  }

  // hook up controls
  el.gameSelect.addEventListener("change", () => loadGame(el.gameSelect.value));
  el.refreshBtn.addEventListener("click", () => loadGame(el.gameSelect.value));
  el.btnFirst.addEventListener("click", () => showIndex(-1));
  el.btnPrev.addEventListener("click",  () => showIndex(state.index - 1));
  el.btnNext.addEventListener("click",  () => showIndex(state.index + 1));
  el.btnLast.addEventListener("click",  () => showIndex(state.moves.length - 1));

  // boot
  loadGameList();
</script>

</body>
</html>
